<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/salte-auth.js | @salte-io/salte-auth</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="OAuth 2.0 for the masses!"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@salte-io/salte-auth"><meta property="twitter:description" content="OAuth 2.0 for the masses!"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/salte-io/salte-auth.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/salte-auth.js~SalteAuth.html">SalteAuth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/salte-auth.profile.js~SalteAuthProfile.html">SalteAuthProfile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/salte-auth.providers.js~Providers.html">Providers</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/salte-auth.utilities.js~SalteAuthUtilities.html">SalteAuthUtilities</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Config">Config</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Validation">Validation</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#providers">providers</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/providers/auth0.js~SalteAuthAuth0Provider.html">SalteAuthAuth0Provider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/providers/azure.js~SalteAuthAzureProvider.html">SalteAuthAzureProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/providers/cognito.js~SalteAuthCognitoProvider.html">SalteAuthCognitoProvider</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/providers/wso2.js~SalteAuthWSO2Provider.html">SalteAuthWSO2Provider</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/salte-auth.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import assign from &apos;lodash/assign&apos;;
import defaultsDeep from &apos;lodash/defaultsDeep&apos;;
import get from &apos;lodash/get&apos;;
import set from &apos;lodash/set&apos;;
import uuid from &apos;uuid&apos;;

import { Providers } from &apos;./salte-auth.providers.js&apos;;
import { SalteAuthProfile } from &apos;./salte-auth.profile.js&apos;;
import { SalteAuthUtilities } from &apos;./salte-auth.utilities.js&apos;;

/**
 * Disable certain security validations if your provider doesn&apos;t support them.
 * @typedef {Object} Validation
 * @property {Boolean} [nonce=true] Passing false will disable nonce validation, leaving you vulnerable to replay attacks.
 * @property {Boolean} [state=true] Passing false will disable state validation, leaving you vulnerable to XSRF attacks.
 * @property {Boolean} [azp=true] Passing false will disable azp validation.
 * @property {Boolean} [aud=true] Passing false will disable aud validation.
 */

/**
 * The configuration for salte auth
 * @typedef {Object} Config
 * @property {String} providerUrl The base url of your identity provider.
 * @property {(&apos;id_token&apos;|&apos;id_token token&apos;)} responseType The response type to authenticate with.
 * @property {String} redirectUrl The redirect url specified in your identity provider.
 * @property {String} clientId The client id of your identity provider
 * @property {String} scope A list of space-delimited claims used to determine what user information is provided and what access is given. Most providers require &apos;openid&apos;.
 * @property {Boolean|Array&lt;String&gt;} routes A list of secured routes. If true is provided then all routes are secured.
 * @property {Array&lt;String|RegExp&gt;} endpoints A list of secured endpoints.
 * @property {(&apos;auth0&apos;|&apos;azure&apos;|&apos;cognito&apos;|&apos;wso2&apos;)} provider The identity provider you&apos;re using.
 * @property {Function} [redirectLoginCallback] A callback that is invoked when a redirect login fails or succeeds.
 * @property {(&apos;session&apos;|&apos;local&apos;)} [storageType=&apos;session&apos;] The Storage api to keep authenticate information stored in.
 * @property {Boolean|Validation} [validation] Used to disable certain security validations if your provider doesn&apos;t support them.
 */

/**
 * Authentication Controller
 */
class SalteAuth {
  /**
   * Sets up Salte Auth
   * @param {Config} config configuration for salte auth
   */
  constructor(config) {
    if (window.salte.auth) {
      return window.salte.auth;
    }

    if (!config) {
      throw new ReferenceError(&apos;A config must be provided.&apos;);
    }

    /**
     * The supported identity providers
     * @type {Providers}
     * @private
     */
    this.$providers = Providers;
    /**
     * The active authentication promises
     * @private
     */
    this.$promises = {};
    /**
     * The configuration for salte auth
     * @private
     */
    this.$config = config;
    this.$config = defaultsDeep(config, this.$provider.defaultConfig);
    /**
     * Various utility functions for salte auth
     * @type {SalteAuthUtilities}
     * @private
     */
    this.$utilities = new SalteAuthUtilities();

    /**
     * The user profile for salte auth
     * @type {SalteAuthProfile}
     */
    this.profile = new SalteAuthProfile(this.$config);

    if (this.$utilities.$iframe) {
      parent.document.body.removeChild(this.$utilities.$iframe);
    } else if (this.$utilities.$popup) {
      // We need to utilize local storage to retain our parsed values
      if (this.$config.storageType === &apos;session&apos;) {
        this.profile.$$transfer(&apos;session&apos;, &apos;local&apos;);
      }
      setTimeout(this.$utilities.$popup.close);
    } else if (this.profile.$redirectUrl &amp;&amp; location.href !== this.profile.$redirectUrl) {
      const error = this.profile.$validate();
      if (error) {
        this.profile.$clear();
      } else {
        location.href = this.profile.$redirectUrl;
        this.profile.$redirectUrl = undefined;
      }
      this.$config.redirectLoginCallback(error);
    } else {
      this.$utilities.addXHRInterceptor((request, data) =&gt; {
        if (this.$utilities.checkForMatchingUrl(request.$url, this.$config.endpoints)) {
          return this.retrieveAccessToken().then((accessToken) =&gt; {
            request.setRequestHeader(&apos;Authorization&apos;, `Bearer ${accessToken}`);
          });
        }
      });

      this.$utilities.addFetchInterceptor((input, options) =&gt; {
        if (this.$utilities.checkForMatchingUrl(input, this.$config.endpoints)) {
          return this.retrieveAccessToken().then((accessToken) =&gt; {
            options.headers = options.headers || {};
            options.headers.Authorization = `Bearer ${accessToken}`;
          });
        }
      });

      window.addEventListener(&apos;popstate&apos;, this.$$onRouteChanged.bind(this));
      document.addEventListener(&apos;click&apos;, this.$$onRouteChanged.bind(this));
      setTimeout(this.$$onRouteChanged.bind(this));
    }
    window.salte.auth = this;
  }

  /**
   * Returns the configured provider
   * @type {Class|Object}
   * @private
   */
  get $provider() {
    if (!this.$config.provider) {
      throw new ReferenceError(&apos;A provider must be specified&apos;);
    }

    if (typeof this.$config.provider === &apos;string&apos;) {
      const provider = this.$providers[this.$config.provider];
      if (!provider) {
        throw new ReferenceError(`Unknown Provider (${this.$config.provider})`);
      }
      return provider;
    }

    return this.$config.provider;
  }

  /**
   * The authentication url to retrieve the access token
   * @type {String}
   * @private
   */
  get $accessTokenUrl() {
    this.profile.$localState = uuid.v4();
    this.profile.$nonce = uuid.v4();

    let authorizeEndpoint = `${this.$config.providerUrl}/authorize`;
    if (this.$provider.authorizeEndpoint) {
      authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);
    }

    return this.$utilities.createUrl(authorizeEndpoint, assign({
      &apos;state&apos;: this.profile.$localState,
      &apos;nonce&apos;: this.profile.$nonce,
      &apos;response_type&apos;: &apos;token&apos;,
      &apos;redirect_uri&apos;: this.$config.redirectUrl,
      &apos;client_id&apos;: this.$config.clientId,
      &apos;scope&apos;: this.$config.scope,
      &apos;prompt&apos;: &apos;none&apos;
    }, this.$config.queryParams));
  }

  /**
   * The authentication url to retrieve the id token
   * @type {String}
   * @private
   */
  get $loginUrl() {
    this.profile.$localState = uuid.v4();
    this.profile.$nonce = uuid.v4();

    let authorizeEndpoint = `${this.$config.providerUrl}/authorize`;
    if (this.$provider.authorizeEndpoint) {
      authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);
    }

    return this.$utilities.createUrl(authorizeEndpoint, assign({
      &apos;state&apos;: this.profile.$localState,
      &apos;nonce&apos;: this.profile.$nonce,
      &apos;response_type&apos;: this.$config.responseType,
      &apos;redirect_uri&apos;: this.$config.redirectUrl,
      &apos;client_id&apos;: this.$config.clientId,
      &apos;scope&apos;: this.$config.scope
    }, this.$config.queryParams));
  }

  /**
   * The url to logout of the configured provider
   * @type {String}
   * @private
   */
  get $deauthorizeUrl() {
    return this.$provider.deauthorizeUrl.call(this, this.$config);
  }

  /**
   * Authenticates using the iframe-based OAuth flow.
   * @return {Promise} a promise that resolves when we finish authenticating
   */
  loginWithIframe() {
    if (this.$promises.login) {
      return this.$promises.login;
    }

    this.profile.$clear();
    this.$promises.login = this.$utilities.createIframe(this.$loginUrl, true).then(() =&gt; {
      this.$promises.login = null;
      const error = this.profile.$validate();

      if (error) {
        this.profile.$clear();
        return Promise.reject(error);
      }
    }).catch((error) =&gt; {
      this.$promises.login = null;
      return Promise.reject(error);
    });

    return this.$promises.login;
  }

  /**
   * Authenticates using the popup-based OAuth flow.
   * @return {Promise} a promise that resolves when we finish authenticating
   */
  loginWithPopup() {
    if (this.$promises.login) {
      return this.$promises.login;
    }

    this.profile.$clear();
    this.$promises.login = this.$utilities.openPopup(this.$loginUrl).then(() =&gt; {
      this.$promises.login = null;
      // We need to utilize local storage to retain our parsed values
      if (this.$config.storageType === &apos;session&apos;) {
        this.profile.$$transfer(&apos;local&apos;, &apos;session&apos;);
      }
      const error = this.profile.$validate();

      if (error) {
        this.profile.$clear();
        return Promise.reject(error);
      }
    }).catch((error) =&gt; {
      this.$promises.login = null;
      return Promise.reject(error);
    });

    return this.$promises.login;
  }

  /**
   * Authenticates using the tab-based OAuth flow.
   * @return {Promise} a promise that resolves when we finish authenticating
   */
  loginWithNewTab() {
    if (this.$promises.login) {
      return this.$promises.login;
    }

    this.profile.$clear();
    this.$promises.login = this.$utilities.openNewTab(this.$loginUrl).then(() =&gt; {
      this.$promises.login = null;
      // We need to utilize local storage to retain our parsed values
      if (this.$config.storageType === &apos;session&apos;) {
        this.profile.$$transfer(&apos;local&apos;, &apos;session&apos;);
      }
      const error = this.profile.$validate();

      if (error) {
        this.profile.$clear();
        return Promise.reject(error);
      }
    }).catch((error) =&gt; {
      this.$promises.login = null;
      return Promise.reject(error);
    });

    return this.$promises.login;
  }

  /**
   * Authenticates using the redirect-based OAuth flow.
   * @return {Promise} a promise that resolves on the next event loop
   */
  loginWithRedirect() {
    if (!this.$config.redirectLoginCallback) {
      throw new ReferenceError(&apos;A redirectLoginCallback is required to invoke &quot;loginWithRedirect&quot;!&apos;);
    }

    if (this.$promises.login) {
      return this.$promises.login;
    }

    // NOTE: This prevents the other login types from racing &quot;loginWithRedirect&quot;.
    // Without this someone could potentially call login somewhere else before
    // the app has a change to redirect. Which could result in an invalid state.
    this.$promises.login = new Promise((resolve) =&gt; setTimeout(resolve));

    this.profile.$clear();
    this.profile.$redirectUrl = this.profile.$redirectUrl || location.href;
    location.href = this.$loginUrl;

    return this.$promises.login;
  }

  /**
   * Unauthenticates using the iframe-based OAuth flow.
   * @return {Promise} a promise that resolves when we finish deauthenticating
   */
  logoutWithIframe() {
    if (this.$promises.logout) {
      return this.$promises.logout;
    }

    this.profile.$clear();
    this.$promises.logout = this.$utilities.createIframe(this.$deauthorizeUrl).then(() =&gt; {
      this.$promises.logout = null;
    });
    return this.$promises.logout;
  }

  /**
   * Unauthenticates using the popup-based OAuth flow.
   * @return {Promise} a promise that resolves when we finish deauthenticating
   */
  logoutWithPopup() {
    if (this.$promises.logout) {
      return this.$promises.logout;
    }

    this.profile.$clear();
    this.$promises.logout = this.$utilities.openPopup(this.$deauthorizeUrl).then(() =&gt; {
      this.$promises.logout = null;
    });

    return this.$promises.logout;
  }

  /**
   * Unauthenticates using the tab-based OAuth flow.
   * @return {Promise} a promise that resolves when we finish deauthenticating
   */
  logoutWithNewTab() {
    if (this.$promises.logout) {
      return this.$promises.logout;
    }

    this.profile.$clear();
    this.$promises.logout = this.$utilities.openNewTab(this.$deauthorizeUrl).then(() =&gt; {
      this.$promises.logout = null;
    });

    return this.$promises.logout;
  }

  /**
   * Logs the user out of their configured identity provider.
   */
  logoutWithRedirect() {
    this.profile.$clear();
    location.href = this.$deauthorizeUrl;
  }

  /**
   * Authenticates, requests the access token, and returns it if necessary.
   * @return {Promise&lt;string&gt;} a promise that resolves when we retrieve the access token
   */
  retrieveAccessToken() {
    if (this.$promises.token) {
      return this.$promises.token;
    }

    this.$promises.token = Promise.resolve();
    if (this.profile.idTokenExpired) {
      if (this.$config.loginType === &apos;popup&apos;) {
        this.$promises.token = this.loginWithPopup();
      } else if ([undefined, null, &apos;iframe&apos;].indexOf(this.$config.loginType) !== -1) {
        this.$promises.token = this.loginWithIframe();
      } else {
        this.$promises.token = null;
        return Promise.reject(new ReferenceError(`Invaid Login Type (${this.$config.loginType})`));
      }
    }

    this.$promises.token = this.$promises.token.then(() =&gt; {
      this.profile.$clearErrors();
      if (this.profile.accessTokenExpired) {
        return this.$utilities.createIframe(this.$accessTokenUrl).then(() =&gt; {
          this.$promises.token = null;
          const error = this.profile.$validate(true);

          if (error) {
            return Promise.reject(error);
          }
          return this.profile.$accessToken;
        });
      }
      this.$promises.token = null;
      return this.profile.$accessToken;
    }).catch((error) =&gt; {
      this.$promises.token = null;
      return Promise.reject(error);
    });

    return this.$promises.token;
  }

  /**
   * Checks if the current route is secured and authenticates the user if necessary
   * @ignore
   */
  $$onRouteChanged() {
    if (!this.$utilities.isRouteSecure(location.href, this.$config.routes)) return;

    this.retrieveAccessToken();
  }
}

set(window, &apos;salte.SalteAuth&apos;, get(window, &apos;salte.SalteAuth&apos;, SalteAuth));
export { SalteAuth };
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
